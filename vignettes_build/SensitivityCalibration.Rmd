---
title: "Model sensitivity analysis and calibration"
author: "Miquel De Caceres"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: TRUE
vignette: >
  %\VignetteIndexEntry{Model sensitivity analysis and calibration}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignettePackage{medfate}
  \usepackage[utf8]{inputenc}
---
<!-- Compile using: -->
<!-- rmarkdown::render("vignettes_build/SensitivityCalibration.Rmd",output_dir = "vignettes") -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## About this vignette

The present document shows how to conduct a sensitivity analyses and calibration exercises on the simulation models included in package `medfate`. The document is written assuming that the user is familiarized with the basic water balance model (i.e. function `spwb`). 

## Preparing model inputs

```{r}
library(medfate)

#Load example daily meteorological data
data(examplemeteo)

#Load example plot plant data
data(exampleforestMED)

#Default species parameterization
data(SpParamsMED)

#Initialize soil with default soil params (4 layers)
examplesoil1 = soil(defaultSoilParams(4))

#Initialize control parameters
control = defaultControl()

#Initialize input
x1 = forest2spwbInput(exampleforestMED,examplesoil1, SpParamsMED, control)
```

Call simulation function with the default parameter settings:

```{r}
S1<-spwb(x1, examplesoil1, examplemeteo, latitude = 41.82592, elevation = 100)
```
## Sensitivity analyses

Model sensitivity analyses are used to investigate how variation in the output of a numerical model can be attributed to variations of its input factors. 

According to Saltelli et al. (2016), there are three main purposes of sensitivity analyses:

 + *Ranking* aims at generating the ranking of the input factors according to their relative contribution to the output variability.
 + *Screening* aims at identifying the input factors, if any, which have a negligible influence on the output variability.
 + *Mapping* aims at determining the region of the input variability space that produces significant output values.

### Input factors and variability space

*Input factors* are elements that can be changed before model execution. They can be model parameters, initial states, boundary conditions or the input forcing data (Pianosi et al. 2016). Here we will take as input factors the values of three plant traits in three plant cohorts, i.e. nine model parameters: 

```{r}
#Parameter names of interest
parNames = c("T1_54/LAI_live", "T2_68/LAI_live", "S1_65/LAI_live",
             "T1_54/Z50", "T2_68/Z50", "S1_65/Z50",
             "T1_54/Psi_Extract", "T2_68/Psi_Extract", "S1_65/Psi_Extract")
#Parameter minimum and maximum values
parMin = c(0.1,0.1,0.1,
           100,100,100,
           -7,-7,-7)
parMax = c(2,2,2,
           500,500,500,
           -1,-1,-1)
```

The previous code defines de parameter names (using naming rules of function `modifyInputParams()`) as well as the input variability space, defined by the minimum and maximum parameter values.


### Scalar model output

In sensitivity analyses, model output is summarized into a single variable whose variation is to be analyzed. Pianosi et al. (2016) distinguish two types of scalar functions:
 
 + *objective functions* (also called loss or cost functions), which are measures of model performance calculated by comparison of modelled and observed variables.
 + *prediction functions*, which are scalar values that are provided to the model-user for their practical use, and that can be computed even in the absence of observations.

Here we will use examples of both kinds. First, we define a function that, given a simulation result, calculates total transpiration (mm) over the simulated period (one year):

```{r}
sf_transp<-function(x) {sum(x$WaterBalance$Transpiration, na.rm=TRUE)}
sf_transp(S1)
```

Another prediction function can focus on plant drought stress. We define a function that, given a simulation result, calculates the average drought stress of plants (measured using the water stress index) over the simulated period:
```{r}
sf_stress<-function(x) {
  lai <- x$spwbInput$above$LAI_live
  lai_p <- lai/sum(lai)
  stress <- spwb_stress(x, index="WSI", draw = F)
  mean(sweep(stress,2, lai_p, "*"), na.rm=T)
}
sf_stress(S1)
```

Sensitivity analysis requires model output functions whose parameters are the input factors to be studied. Hence we need functions that take trait values as input, run the soil plant water balance model and return the desired prediction function. These functions can be generated using the function factory `optimization_function()`.

```{r}
of_transp<-optimization_function(parNames = parNames,
                                 x = x1, soil = examplesoil1,
                                 meteo = examplemeteo, 
                                 latitude = 41.82592, elevation = 100,
                                 summary_function = sf_transp)
```

The object `of_transp` is a function itself, which we can call with parameter values (or sets of parameter values) as input:
```{r}
of_transp(parMin)
of_transp(parMax)
```
It is important to understand how the process works: (1) Function `of_transp()` internally calls `spwb()` using all the parameters specified in its construction (i.e. in the call to the function factory), except for the input factors, which are specified as input at the time of calling `of_transp()`; (2) The result of soil plant water balance is then passed to function `sf_transp()` and the output of this last function is returned as output of `of_transp()`.

We can build a similar model output function, in this case focusing on plant stress (note that the only difference in the call to the factory is in the specification of `sf_stress` as summary function, instead of `sf_transp`). 
```{r}
of_stress<-optimization_function(parNames = parNames,
                                 x = x1, soil = examplesoil1,
                                 meteo = examplemeteo, 
                                 latitude = 41.82592, elevation = 100,
                                 summary_function = sf_stress)
of_stress(parMin)
of_stress(parMax)
```

```{r}
data(exampleobs)
of_eval<-optimization_evaluation_function(parNames = parNames,
                x = x1, soil = examplesoil1,
                meteo = examplemeteo, latitude = 41.82592, elevation = 100,
                measuredData = exampleobs, type = "SWC", 
                metric = "loglikelihood")

```

```{r}
of_eval(parMin)
of_eval(parMax)
```

### Sensitivity analysis using Elementary Effect Test

Here we will conduct sensitivity analyses using function `morris` implemented in package **sensitivity**:

```{r}
library(sensitivity)
```

```{r, eval = FALSE}
sa_transp <- morris(of_transp, parNames, r =20, 
             design = list(type = "oat", levels = 10, grid.jump = 3), 
             binf = parMin, bsup = parMax, scale=TRUE, verbose=T)
```

```{r, eval = TRUE, echo=FALSE}
# saveRDS(sa_transp, file="sa_transp.rds")
sa_transp = readRDS("sa_transp.rds")
```

```{r}
print(sa_transp)
```


```{r, eval = FALSE}
sa_stress <- morris(of_stress, parNames, r =20, 
             design = list(type = "oat", levels = 10, grid.jump = 3), 
             binf = parMin, bsup = parMax, scale=TRUE, verbose=FALSE)
```

```{r, eval = TRUE, echo=FALSE}
# saveRDS(sa_stress, file="sa_stress.rds")
sa_stress = readRDS("sa_stress.rds")
```

```{r}
print(sa_stress)
```

```{r, eval = FALSE}
sa_eval <- morris(of_eval, parNames, r =10, 
             design = list(type = "oat", levels = 10, grid.jump = 3), 
             binf = parMin, bsup = parMax, scale=TRUE, verbose=TRUE)
```

```{r, eval = TRUE, echo=FALSE}
# saveRDS(sa_eval, file="sa_eval.rds")
sa_eval = readRDS("sa_eval.rds")
```

```{r}
print(sa_eval)
```

## Calibration

### Defining parameter space and optimization function
```{r}
#Parameter names of interest
parNames = c("T1_54/Z50", "T2_68/Z50", "S1_65/Z50")
#Parameter minimum and maximum values
parMin = c(100,100,100)
parMax = c(1000,1000,1000)
parIni = x1$below$Z50
```

```{r}
of_eval<-optimization_evaluation_function(parNames = parNames,
                x = x1, soil = examplesoil1,
                meteo = examplemeteo, latitude = 41.82592, elevation = 100,
                measuredData = exampleobs, type = "SWC", 
                metric = "loglikelihood")

```

### Calibration by gradient search

```{r, eval = FALSE}
opt_cal = optim(parIni, of_eval, method = "L-BFGS-B",
                control = list(fnscale = -1), verbose = FALSE)
```

```{r, eval = TRUE, echo=FALSE}
# saveRDS(opt_cal, file="opt_cal.rds")
opt_cal = readRDS("opt_cal.rds")
```

```{r}
print(opt_cal)
```


### Bayesian calibration
```{r}
library(BayesianTools)
```

```{r}
mcmc_setup <- createBayesianSetup(
  likelihood = of_eval, 
  prior = createUniformPrior(parMin, parMax, parIni), 
  names = parNames)
```


```{r, eval = FALSE}
mcmc_out <- runMCMC(
  bayesianSetup = mcmc_setup, 
  sampler = "DEzs",
  settings = list(iterations = 3000, nrChains = 3))
```

```{r, eval = TRUE, echo=FALSE}
# saveRDS(mcmc_out, file="mcmc_out.rds")
mcmc_out = readRDS("mcmc_out.rds")
```

```{r}
summary(mcmc_out)
```

```{r, fig.height=8, fig.width=6.6}
plot(mcmc_out)
```


```{r, fig.height=7, fig.width=6.6}
marginalPlot(mcmc_out, prior = T)
```


```{r, fig.height=6.6, fig.width=6.6}
correlationPlot(mcmc_out)
```

```{r}
s = getSample(mcmc_out, numSamples = 50)
```

```{r, eval = FALSE}
MS = multiple_runs(s, x = x1, soil = examplesoil1, meteo = examplemeteo,
                   latitude = 41.82592, elevation = 100, summary_function = sf_transp,
                   verbose = FALSE)
```

## References

+ Pianosi, F., Beven, K., Freer, J., Hall, J.W., Rougier, J., Stephenson, D.B., Wagener, T., 2016. Sensitivity analysis of environmental models: A systematic review with practical workflow. Environ. Model. Softw. 79, 214â€“232. https://doi.org/10.1016/j.envsoft.2016.02.008

+ Bertrand Iooss, Sebastien Da Veiga, Alexandre Janon, Gilles Pujol, with contributions from Baptiste Broto, Khalid Boumhaout, Thibault Delage, Reda El Amri, Jana Fruth, Laurent Gilquin, Joseph Guillaume, Loic Le Gratiet, Paul Lemaitre, Amandine Marrel, Anouar Meynaoui, Barry L. Nelson, Filippo Monari, Roelof Oomen, Oldrich Rakovec, Bernardo Ramos, Olivier Roustant, Eunhye Song, Jeremy Staum, Roman Sueur, Taieb Touati and Frank Weber (2020). sensitivity: Global Sensitivity Analysis of Model Outputs. R package version 1.23.1. https://CRAN.R-project.org/package=sensitivity
