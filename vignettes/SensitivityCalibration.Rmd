---
title: "Model sensitivity analysis and calibration"
author: "Miquel De Caceres"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: TRUE
vignette: >
  %\VignetteIndexEntry{Model sensitivity analysis and calibration}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignettePackage{medfate}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(medfate)
```

## About this vignette

The present document describes how to run the soil plant water balance model described in De CÃ¡ceres et al. (2015) using package `medfate`. The  document indicates how to prepare the inputs, use the simulation functions and inspect the outputs. All the details of the model design and formulation can be found at https://vegmod.ctfc.cat/software/medfate/. Because it introduces many basic features of package `medfate`, this document should be read before addressing advanced topics of water balance simulations or growth simulations.

## Preparing model inputs

```{r}
#Load example daily meteorological data
data(examplemeteo)

#Load example plot plant data
data(exampleforestMED)

#Default species parameterization
data(SpParamsMED)

#Initialize soil with default soil params (4 layers)
examplesoil1 = soil(defaultSoilParams(4))

#Initialize control parameters
control = defaultControl()

#Initialize input
x1 = forest2spwbInput(exampleforestMED,examplesoil1, SpParamsMED, control)

```

```{r}
#Call simulation function
S1<-spwb(x1, examplesoil1, examplemeteo, latitude = 41.82592, elevation = 100)
```

```{r}
#Define a summary function as the total transpiration over the simulated period
sf_transp<-function(x) {sum(x$WaterBalance$Transpiration, na.rm=TRUE)}
sf_transp(S1)
```


```{r}
sf_stress<-function(x) {
  lai <- x$spwbInput$above$LAI_live
  lai_p <- lai/sum(lai)
  stress <- spwb_stress(x, index="WSI", draw = F)
  mean(sweep(stress,2, lai_p, "*"), na.rm=T)
}
sf_stress(S1)
```

```{r}
#Parameter names of interest
parNames = c("T1_54/LAI_live", "T2_68/LAI_live", "S1_65/LAI_live",
             "T1_54/Z50", "T2_68/Z50", "S1_65/Z50",
             "T1_54/Psi_Extract", "T2_68/Psi_Extract", "S1_65/Psi_Extract")
#Parameter minimum and maximum values
parMin = c(0.1,0.1,0.1,
           100,100,100,
           -7,-7,-7)
parMax = c(2,2,2,
           500,500,500,
           -1,-1,-1)
```


```{r}
of_transp<-optimization_function(parNames = parNames,
                                 x = x1, soil = examplesoil1,
                                 meteo = examplemeteo, 
                                 latitude = 41.82592, elevation = 100,
                                 summary_function = sf_transp)
of_transp(parMin)
of_transp(parMax)
```


```{r}
of_stress<-optimization_function(parNames = parNames,
                                 x = x1, soil = examplesoil1,
                                 meteo = examplemeteo, 
                                 latitude = 41.82592, elevation = 100,
                                 summary_function = sf_stress)
of_stress(parMin)
of_stress(parMax)
```

```{r}
data(exampleobs)
of_eval<-optimization_evaluation_function(parNames = parNames,
                x = x1, soil = examplesoil1,
                meteo = examplemeteo, latitude = 41.82592, elevation = 100,
                measuredData = exampleobs, type = "SWC", 
                metric = "loglikelihood")

```

```{r}
of_eval(parMin)
of_eval(parMax)
```

## Sensitivity analysis
```{r}
library(sensitivity)
```

```{r, eval = FALSE}
sa_transp <- morris(of_transp, parNames, r =20, 
             design = list(type = "oat", levels = 10, grid.jump = 3), 
             binf = parMin, bsup = parMax, scale=TRUE, verbose=FALSE)
print(sa_transp)
```

```{r, eval = FALSE}
sa_stress <- morris(of_stress, parNames, r =20, 
             design = list(type = "oat", levels = 10, grid.jump = 3), 
             binf = parMin, bsup = parMax, scale=TRUE, verbose=FALSE)
print(sa_stress)
```

```{r, eval = FALSE}
sa_eval <- morris(of_eval, parNames, r =10, 
             design = list(type = "oat", levels = 10, grid.jump = 3), 
             binf = parMin, bsup = parMax, scale=TRUE, verbose=TRUE)
print(sa_eval)
```

## Calibration

```{r}
#Parameter names of interest
parNames = c("T1_54/Z50", "T2_68/Z50", "S1_65/Z50")
#Parameter minimum and maximum values
parMin = c(100,100,100)
parMax = c(1000,1000,1000)
parIni = x1$below$Z50
```

```{r}
of_eval<-optimization_evaluation_function(parNames = parNames,
                x = x1, soil = examplesoil1,
                meteo = examplemeteo, latitude = 41.82592, elevation = 100,
                measuredData = exampleobs, type = "SWC", 
                metric = "loglikelihood")

```

```{r}
optim(parIni, of_eval, method = "L-BFGS-B",
      control = list(fnscale = -1), verbose = FALSE)
```

```{r}
library(BayesianTools)
mcmc_setup <- createBayesianSetup(
  likelihood = of_eval, 
  prior = createUniformPrior(parMin, parMax, parIni), 
  names = parNames)
```

```{r}
mcmc_out <- runMCMC(
  bayesianSetup = mcmc_setup, 
  sampler = "DEzs",
  settings = list(iterations = 3000, nrChains = 3))
```

```{r}
gelmanDiagnostics( mcmc_out )
```

```{r}
plot(mcmc_out)
```


```{r}
marginalPlot(mcmc_out, prior = T)
```


```{r}
correlationPlot(mcmc_out)
```

